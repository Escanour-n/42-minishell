     1	/* ************************************************************************** */
     2	/*                                                                            */
     3	/*                                                        :::      ::::::::   */
     4	/*   main.c                                             :+:      :+:    :+:   */
     5	/*                                                    +:+ +:+         +:+     */
     6	/*   By: nouakhro <nouakhro@student.42.fr>          +#+  +:+       +#+        */
     7	/*                                                +#+#+#+#+#+   +#+           */
     8	/*   Created: 2023/03/02 15:07:52 by nouakhro          #+#    #+#             */
     9	/*   Updated: 2023/05/09 15:50:18 by nouakhro         ###   ########.fr       */
    10	/*                                                                            */
    11	/* ************************************************************************** */
      	
    12	#include "../include/minishell.h"
      	
    13	void	handler(int sig)
    14	{
    15		if (sig == SIGINT)
    16		{
    17			// rl_replace_line("", 0);
    18			printf("\n");
    19			rl_on_new_line();
    20			rl_redisplay();
    21		}
    22		if (sig == SIGQUIT)
    23			return ;
    24	}
      	
    25	int	after_parccing(int c_of_s)
    26	{
    27		int	i;
      	
    28		i = 0;
    29		c_of_s = _parent_builtins(c_of_s);
    30		if (c_of_s != 2)
    31			return (c_of_s);
    32		_path_comanmde(i);
    33		c_of_s = 0;
    34		while (c_of_s < g_struct.number_of_pipes - 1)
    35		{
    36			pipe(g_struct.each_cmd[c_of_s].fd);
    37			c_of_s++;
    38		}
    39		c_of_s = 0;
    40		pipe_is_exist_or_its_not_builtins(c_of_s, i);
    41		free_all_v2(1);
    42		return (2);
    43	}
      	
    44	void	del(void *node)
    45	{
    46		free(node);
    47	}
      	
    48	void	free_linked_list(void)
    49	{
    50		ft_lstclear(&g_struct.list, del);
    51	}
      	
    52	int	main(int argc, char **argv, char **env)
    53	{
    54		(void)argv;
    55		(void)argc;
    56		g_struct.list = NULL;
    57		fill_linked_list(env, &g_struct.list);
    58		g_struct.exit_status = 0;
    59		// signal(SIGINT, &handler);
    60		// signal(SIGQUIT, &handler);
    61		while (1)
    62		{
    63			g_struct.the_commande = 0;
    64			g_struct.cmd = readline("escanour > ");
    65			if (!g_struct.cmd)
    66			{
    67				free_linked_list();
    68				exit(g_struct.exit_status);
    69			}
    70			if (ft_strlen(g_struct.cmd) != 0)
    71				g_struct.exit_status = somting_in_readline();
    72			free(g_struct.cmd);
    73		}
    74	}
